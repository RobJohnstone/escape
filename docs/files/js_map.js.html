<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>js/map.js - escape</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="escape"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.4-17</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/actorPrototype.html">actorPrototype</a></li>
            
                <li><a href="../classes/actors.html">actors</a></li>
            
                <li><a href="../classes/baddyPrototype.html">baddyPrototype</a></li>
            
                <li><a href="../classes/campaign.html">campaign</a></li>
            
                <li><a href="../classes/entities.html">entities</a></li>
            
                <li><a href="../classes/entityPrototype.html">entityPrototype</a></li>
            
                <li><a href="../classes/game.html">game</a></li>
            
                <li><a href="../classes/graphics.html">graphics</a></li>
            
                <li><a href="../classes/input.html">input</a></li>
            
                <li><a href="../classes/map.html">map</a></li>
            
                <li><a href="../classes/objectPrototype.html">objectPrototype</a></li>
            
                <li><a href="../classes/palette.html">palette</a></li>
            
                <li><a href="../classes/playerPrototype.html">playerPrototype</a></li>
            
                <li><a href="../classes/polyfills.html">polyfills</a></li>
            
                <li><a href="../classes/projectilePrototype.html">projectilePrototype</a></li>
            
                <li><a href="../classes/screen.html">screen</a></li>
            
                <li><a href="../classes/tiles.html">tiles</a></li>
            
                <li><a href="../classes/timer.html">timer</a></li>
            
                <li><a href="../classes/util.html">util</a></li>
            
                <li><a href="../classes/vector.html">vector</a></li>
            
                <li><a href="../classes/weapons.html">weapons</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/actorPrototype.html">actorPrototype</a></li>
            
                <li><a href="../modules/actors.html">actors</a></li>
            
                <li><a href="../modules/baddyPrototype.html">baddyPrototype</a></li>
            
                <li><a href="../modules/campaign.html">campaign</a></li>
            
                <li><a href="../modules/entities.html">entities</a></li>
            
                <li><a href="../modules/game.html">game</a></li>
            
                <li><a href="../modules/graphics.html">graphics</a></li>
            
                <li><a href="../modules/input.html">input</a></li>
            
                <li><a href="../modules/map.html">map</a></li>
            
                <li><a href="../modules/objectPrototype.html">objectPrototype</a></li>
            
                <li><a href="../modules/palette.html">palette</a></li>
            
                <li><a href="../modules/playerPrototype.html">playerPrototype</a></li>
            
                <li><a href="../modules/polyfills.html">polyfills</a></li>
            
                <li><a href="../modules/projectilePrototype.html">projectilePrototype</a></li>
            
                <li><a href="../modules/screen.html">screen</a></li>
            
                <li><a href="../modules/tiles.html">tiles</a></li>
            
                <li><a href="../modules/timer.html">timer</a></li>
            
                <li><a href="../modules/util.html">util</a></li>
            
                <li><a href="../modules/vector.html">vector</a></li>
            
                <li><a href="../modules/weapons.html">weapons</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: js/map.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Map module. Objects and methods concerning the map
 *
 * @module map
 * @class map
 */
E.map = (function() {
	&quot;use strict&quot;;

	var map = {
		offset: {
			x: 0,
			y: 0
		}
	};

	var _mapTemplate = {
		name: &#x27;&#x27;,
		description: &#x27;&#x27;,
		columns: 0,
		rows: 0,
		tileWidth: 0,
		tileHeight: 0,
		width: 0,
		height: 0,
		data: [],
		actors: []
	};

	/**
	 * initialise the map based on a loaded map object
	 *
	 * @method init
	 * @param mapObj {object} information about the map loaded from file (optional)
	 * @return this
	 */
	map.init = function(mapObj) {
		var template = $(&#x27;#mapScreenTemplate&#x27;).text().trim(),
			compiled = _.template(template);
		if (mapObj) {
			map.actors = [];
			$.extend(true, map, mapObj);
		}
		E.tiles.init(&#x27;&#x27;, map.tileWidth, map.tileHeight);
		map.pathGrid = [];
		var i = 0;
		for (var row=0; row&lt;map.rows; row++) {
			map.pathGrid.push([]);
			for (var col=0; col&lt;map.columns; col++) {
				map.pathGrid[row].push(!map.getTileObj(map.data[i]).passable); // need to modify to check if tile is passable rather than this hack
				i++;
			}
		}
		E.entities.instances = [];
		for (i=0; i&lt;map.actors.length; i++) {
			var actor = E.actors.create(map.actors[i]);
			if (actor.type === &#x27;player&#x27;) {
				E.player = actor;
			}
		}
		$(&#x27;#mapScreen&#x27;).html(compiled(map));
		return this;
	};

	/**
	 * load the map data
	 *
	 * @method load
	 * @param mapName {string} the name of the map. This should also be the filename minus the extension 
	 * if mapName is an object it will be treated as the mapObj and loaded instead of requesting the object
	 * from the server
	 * @param onLoad {function} the function to be called once the map has loaded
	 * @return this
	 */
	map.load = function(mapName, onLoad) {
		if (typeof mapName === &quot;object&quot;) {
			_loadMapObj(mapName);
		}
		else {
			$.ajax({
				url: &#x27;/maps/&#x27;+mapName,
				type: &#x27;get&#x27;,
				dataType: &#x27;json&#x27;,
				success: function(mapObj) {
					_loadMapObj(mapObj);
				},
				error: function(jqXHR, textStatus, errorThrown) {
					throw new Error(&#x27;map loading error: &#x27;+textStatus);
				}
			});
		}
		return this;

		/**
		 * takes the map object and inserts it into the engine
		 *
		 * @method _loadMapObj
		 * @param mapObj {object} The map object to load
		 */
		function _loadMapObj(mapObj) {
			map.init(mapObj);
			if (typeof onLoad === &#x27;function&#x27;) {
				onLoad();
			}
		}
	};

	/**
	 * Creates a new blank map object
	 *
	 * @method new
	 * @param mapName {string} The filename of the new map minus the json extension
	 * @param cols {number} The number of columns in the map (defaults to 50)
	 * @param rows {number} The number of rows in the map (defaults to 50)
	 * @return mapObj {object}
	 */
	map.newMap = function(mapName, cols, rows) {
		cols = cols || 50;
		rows = rows || 50;
		var mapObj = _mapTemplate.clone();
		mapObj.name = mapName;
		mapObj.columns = cols;
		mapObj.rows = rows;
		mapObj.tileWidth = 64;
		mapObj.tileHeight = 64;
		mapObj.width = 64*cols;
		mapObj.height = 64*rows;
		for (var i=0, len=cols*rows; i&lt;len; i++) {
			mapObj.data[i] = 0;
		}
		return mapObj;
	};

	/**
	 * Updates map values
	 *
	 * @method update
	 * @param field {string} The field to update (either the property name or a the id of a form element associated with that property)
	 * @param value {any} The new value
	 * @return this
	 */
	map.update = function(field, value) {
		if (field.substr(0, 3) === &#x27;map&#x27;) {
			field = field.substr(3);
			field = field.charAt(0).toLowerCase() + field.slice(1);
		}
		map[field] = value;
		return this;
	};

	/**
	 * Saves the map on the server (this should only be allowed on the dev server)
	 *
	 * @method save
	 * @return this
	 */
	map.save = function() {
		var data = {
			name: map.name,
			description: map.description,
			columns: map.columns,
			rows: map.rows,
			tileWidth: map.tileWidth,
			tileHeight: map.tileHeight,
			actors: E.entities.instances.filter(function(entity) {
				return entity.abbr; // ensure only actors and not other entities
			}).map(function(entity) {
				return entity.abbr();
			}),
			data: map.data

		};
		$.ajax({
			url: &#x27;/maps/&#x27;+map.name,
			type: &#x27;post&#x27;,
			data: {data: JSON.stringify(data)}
		});
		return this;
	};

	/**
	 * renders the map
	 *
	 * @method render
	 * @return this
	 */
	map.render = function() {
		var floor = Math.floor,
			ceil = Math.ceil,
			rowStart = floor(-map.offset.y / E.tiles.tileHeight),
			rowEnd = ceil((E.graphics.gameCanvas.height - map.offset.y) / E.tiles.tileHeight),
			colStart = floor(-map.offset.x / E.tiles.tileWidth),
			colEnd = ceil((E.graphics.gameCanvas.width - map.offset.x) / E.tiles.tileWidth);
		for (var row=rowStart; row&lt;rowEnd; row++) {
			for (var col=colStart; col&lt;colEnd; col++) {
				var x = map.offset.x + (col * E.tiles.tileWidth),
					y = map.offset.y + (row * E.tiles.tileHeight);
				E.tiles.renderTile(map.data[row*map.columns + col], x, y);
			}
		}
		return this;
	};

	/**
	 * Checks that a position is within the bounds of the map
	 *
	 * @method checkWithinBounds
	 * @param pos {vector} the position to test
	 * @return {boolean} true if the position is within the bounds of the map, false otherwise
	 */
	map.checkWithinBounds = function(pos) {
		if (pos.x &lt; 0 || pos.x &gt; map.width || pos.y &lt; 0 || pos.y &gt; map.height)
			return false;
		else
			return true;
	};

	/**
	 * Gets the tile object for the tile index
	 *
	 * @method getTileObj
	 * @return this
	 */
	map.getTileObj = function(tileIndex) {
		var tile = map.data[tileIndex];
		if (tile === undefined) {
			return false;
		}
		else return E.tiles.tileset[tile];
	};

	/**
	 * Checks that a particular tile is passable
	 *
	 * @method isPassable
	 * @param tileIndex {number} the index of the tile within the E.tiles.tiles array
	 * @return {boolean} true if the tile is passable, false otherwise
	 */
	map.isPassable = function(tileIndex) {
		return map.getTileObj(tileIndex).passable;
	};

	/** Checks if an entity is about to collide with an impassable tile on the map and, if so, returns a more appropriate vector
	 *
	 * @method collisionAdjust
	 * @param entity {entity} the entity that is moving
	 * @param v {vector} the desired movement vector of the entity
	 * @return {vector} an allowable movement vector
	 */
	map.collisionAdjust = function(entity, v) {
		var cornerCollisions, testV,
			magnitude = E.vector.mag(v),
			testVectors = [v];
		// if v doesn&#x27;t work then we&#x27;re going try the individual x and y components of v scaled to the appropriate length
		if (v.x) testVectors.push(E.vector.setLength({x: v.x, y: 0}, magnitude));
		if (v.y) testVectors.push(E.vector.setLength({x: 0, y: v.y}, magnitude));
		// and if they don&#x27;t work we are blocked and so stay where we are
		testVectors.push({x:0, y:0});

		for (var i=0; i&lt;testVectors.length; i++) {
			testV = testVectors[i];
			cornerCollisions = cornersCollide(entity, testV);
			if (cornerCollisions.length === 0) {
				return testV;
			}
			else if (cornerCollisions.length === 1) { // nudge around the corner as it&#x27;s clear what the player is trying to do
				return nudge(testV, cornerCollisions[0], entity);
			}
		}

		/* Returns true if the point collides with an impassable tile on the map */
		function pointCollides(point, v) {
			var testPos = E.vector.round(E.vector.add(point, v));
			var testTile = map.getTileIndex(testPos);
			return !map.isPassable(testTile);
		}

		/* Returns the number of corners of the entity&#x27;s bounding box that collide with impassable tiles on the map */
		function cornersCollide(entity, v) {
			var collisions = [],
				corners = {
					topLeft: {x: entity.x-entity.halfWidth, y: entity.y-entity.halfHeight},
					topRight: {x: entity.x+entity.halfWidth, y: entity.y-entity.halfHeight},
					bottomRight: {x: entity.x+entity.halfWidth, y: entity.y+entity.halfHeight},
					bottomLeft: {x: entity.x-entity.halfWidth, y: entity.y+entity.halfHeight}
				};
			for (var corner in corners) {
				if (pointCollides(corners[corner], v)) collisions.push(corner);
			}
			return collisions;
		}

		/* Returns a vector that will steer the entity away from a collision if only one of it&#x27;s corners has collided with impassable tiles on the map */
		function nudge(v, collidingCorner, entity) {
			var sideLength = Math.sqrt(entity.halfWidth * entity.halfWidth + entity.halfHeight * entity.halfHeight),
				cornerVectors = {
					topLeft: {x:-1, y:-1},
					topRight: {x:1, y:-1},
					bottomRight: {x:1, y:1},
					bottomLeft: {x:-1, y:1}
				},
				cornerVector = cornerVectors[collidingCorner],
				nudgeVector = E.vector.subtract(cornerVector, {x:0, y:0});
			return E.vector.setLength(nudgeVector, E.vector.mag(nudgeVector) * sideLength / 2);
		}
	};

	/**
	 * Scrolls the map so that it is looking at the passed position
	 *
	 * @method position
	 * @param position {vector} The position to look at
	 * @return this
	 */
	map.position = function(position) {
		map.offset = {
			x: Math.round(E.graphics.gameCanvas.width / 2) - position.x,
			y: Math.round(E.graphics.gameCanvas.height / 2) - position.y
		};
		if (map.offset.x &gt; 0) map.offset.x = 0;
		if (map.offset.y &gt; 0) map.offset.y = 0;
		if (map.offset.x &lt; E.graphics.gameCanvas.width-(map.columns * E.tiles.tileWidth)) map.offset.x = E.graphics.gameCanvas.width-(map.columns * E.tiles.tileWidth);
		if (map.offset.y &lt; E.graphics.gameCanvas.height-(map.rows * E.tiles.tileHeight)) map.offset.y = E.graphics.gameCanvas.height-(map.rows * E.tiles.tileHeight);
		return this;
	};

	/* TODO: All these get methods should be memoized but there also needs to be a means of resetting them when a new map is loaded. The same is true of .isPassable above */
	/**
	 * Returns the index of the tile corresponding to the passed postion
	 *
	 * @method getTileIndex
	 * @param position {vector} the position to test
	 * @return {number} the index of the appropriate tile or undefined if there is no tile at that position
	 */
	map.getTileIndex = function(position) {
		if(map.checkWithinBounds(position)) {
			var col = Math.floor(position.x / E.tiles.tileWidth),
				row = Math.floor(position.y / E.tiles.tileHeight);
			return (row * map.columns) + col;
		}
		else return undefined;
	};

	/**
	 * Returns a vector indicating the position of the centre of the tile
	 *
	 * @method getTileCentre
	 * @param tile {number} The tile to consider. If an object is passed it will try to determine the tile based on the x and y properties of the object
	 * @return {vector} The postion of the centre of the tile
	 */
	map.getTileCentre = function(tile) {
		if (Object.prototype.toString.call(tile) === &#x27;[object Array]&#x27;) {
			tile = map.getTileFromCoords(tile);
		}
		var col = tile % map.columns,
			row = Math.floor(tile / map.columns);
		return ({
			x: (col * E.tiles.tileWidth) + (E.tiles.tileWidth / 2),
			y: (row * E.tiles.tileHeight) + (E.tiles.tileHeight / 2)
		});
	};

	/**
	 * Converts a tile index into 2d coordinates within the tiles array
	 *
	 * @method getTileCoords
	 * @param tile {number} The tile index
	 * @return {array} The first element is the x coordinate, the second the y coordinate
	 */
	map.getTileCoords = function(tile) {
		if (Object.prototype.toString.call(tile) === &#x27;[object Array]&#x27;) { // check if 2d coords rather than straight tile no
			tile = tile[0] + tile[1] * map.columns;
		}
		return [tile % map.columns, Math.floor(tile / map.columns)];
	};

	/**
	 * Converts 2d tile coords (not pixel coords) into a tile index
	 *
	 * @method getTileFromCoords
	 * @param x {number} The x coord of the tile
	 * @param y {number} The y coord of the tile
	 * @return {number} The tile index
	 */
	map.getTileFromCoords = function(x, y) {
		if (Object.prototype.toString.call(x) === &#x27;[object Array]&#x27;) {
			y = x[1];
			x = x[0];
		}
		return (y * map.columns) + x;
	};

	/**
	 * Checks if a line between two points can pass unimpeeded by the map
	 * Note that this does not check for collisions with entities
	 *
	 * @method lineTraversable
	 * @param start {vector} The start location
	 * @param end {vector} The end location
	 * @return {boolean} True if there are no impassable tiles between the start and end points, false otherwise
	 */
	map.lineTraversable = function(start, end) {
		var diff = E.vector.subtract(start, end),
			distance = E.vector.mag(diff),
			vel = E.vector.normalise(diff),
			pos = E.vector.clone(start),
			tile,
			endTile = map.getTileIndex(end);
		for (var i=0; i&lt;distance; i++) {
			pos = E.vector.add(pos, vel);
			tile = map.getTileIndex(pos);
			if (tile === endTile) {
				return true;
			}
			if (!map.getTileObj(tile).passable) {
				return false;
			}
		}
		return true;
	};

	/**
	 * Higlights the tile indicated
	 *
	 * @method highlightTile
	 * @param tileIndex {number} The tileIndex of the tile to highlight
	 * @return this
	 */
	map.highlightTile = function(tileIndex, colour) {
		if (E.graphics.gameCanvas) {
			var tileCentre = map.getTileCentre(tileIndex);
			colour = colour || &#x27;white&#x27;;
			E.graphics.vectors.rect({
				x: tileCentre.x-E.tiles.tileWidth/2,
				y: tileCentre.y-E.tiles.tileHeight/2
			}, {
				x: E.tiles.tileWidth,
				y: E.tiles.tileHeight
			}, colour);
		}
		return this;
	};

	/**
	 * highlights the tile under the mouse cursor
	 *
	 * @method highlightMouseTile
	 * @return this
	 */
	map.highlightMouseTile = function() {
		map.highlightTile(map.getTileIndex(E.input.mouseState));
		return this;
	};

	/**
	 * Resizes the map
	 *
	 * @method resize
	 * @param delta {object} The four properties (top, right, bottom, left) indicate how many columns/rows to add. Negative numbers shrink the map
	 * @return this
	 */
	map.resize = function(delta) {
		var index;
		delta.top = delta.top || 0;
		delta.right = delta.right || 0;
		delta.bottom = delta.bottom || 0;
		delta.left = delta.left || 0;
		if (delta.top) {
			map.rows += delta.top;
			if (delta.top &gt; 0) {
				map.data = _blankRows(delta.top).concat(map.data);
			}
			else if (delta.top &lt; 0) {
				map.data.splice(0, map.columns);
			}
		}
		if (delta.right) {
			map.columns += delta.right;
			if (delta.right &gt; 0) {
				for (index=map.columns; index&lt;map.data.length; index+= map.columns) {
					map.data.splice(index, 0, 0);
				}
			}
			else if (delta.right &lt; 0) {
				for (index=map.columns; index&lt;map.data.length; index+= map.columns) {
					map.data.splice(index, 1);
				}
			}
		}
		if (delta.bottom) {
			map.rows += delta.bottom;
			if (delta.bottom &gt; 0) {
				map.data = map.data.concat(_blankRows(delta.bottom));
			}
			else if (delta.bottom &lt; 0) {
				map.data.splice(-map.columns, map.columns);
			}
		}
		if (delta.left) {
			map.columns += delta.left;
			if (delta.left &gt; 0) {
				for (index=0; index&lt;map.data.length; index+= map.columns) {
					map.data.splice(index, 0, 0);
				}
			}
			else if (delta.left &lt; 0) {
				for (index=0; index&lt;map.data.length; index+= map.columns) {
					map.data.splice(index, 1);
				}
			}
		}

		var tempEntities = [];

		E.entities.instances.forEach(function(entity, index) {
			entity.x = entity.x + (delta.left * map.tileWidth);
			entity.y = entity.y + (delta.top * map.tileHeight);
			if (map.checkWithinBounds(entity)) {
				tempEntities.push(entity);
			}
		});

		E.entities.instances = tempEntities;

		if (!E.graphics.clipping) {
			E.graphics.resizeCanvas(&#x27;game&#x27;, map.columns * map.tileWidth, map.rows * map.tileHeight);
		}
		return this;

		function _blankRows(numRows) {
			var newData = new Array(map.columns * numRows);
			for (var i=0; i&lt;newData.length; i++) {
				newData[i] = 0;
			}
			return newData;
		}
	};

	/**
	 * Returns a string indicating the side of the map closest to the mouse cursor
	 *
	 * @method sideClosestToCursor
	 * @return {string}
	 */
	map.sideClosestToCursor = function() {
		var mapWidth, mapHeight, mapCentre, diff, angle, quadrant,
			quadrants = [&#x27;top&#x27;, &#x27;right&#x27;, &#x27;bottom&#x27;, &#x27;left&#x27;];
		mapWidth = map.tileWidth * map.columns;
		mapHeight = map.tileHeight * map.rows;
		mapCentre = {x: mapWidth/2, y: mapHeight/2};
		diff = E.vector.subtract(mapCentre, E.input.mouseState);
		diff = { // adjust for the fact that the map is unlikely to be perfectly square
			x: diff.x / mapWidth,
			y: diff.y / mapHeight
		};
		angle = E.vector.angle({x: mapCentre.x/mapWidth, y: mapCentre.y/mapHeight}, diff, true);
		quadrant = Math.floor(angle * 2 / Math.PI) + 2;
		return quadrants[quadrant];
	};

	return map;
})();
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
